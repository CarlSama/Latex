    
\begin{description}
    \item{\textbf{Question}}:\\%textbf加粗
		Given a linked list, swap every two adjacent nodes and return its head.

    \item{\textbf{Example}}\\
		Given 1->2->3->4, you should return the list as 2->1->4->3.\\
		Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

    \item{\textbf{Anslysis}}\\
		最简单的方法当然是直接交换相邻节点的值，而非操作指针。可是被题目禁止，在面试时可以询问面试官是否可以直接操作节点所包含的值。\\				
		本题目有迭代和递归两种做法。\\


    \item{\textbf{Solution}}
	\item{递归} : \fbox{时间复杂度O(n) , 空间复杂度O(n) }\\
		\begin{lstlisting}
public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode newhd = head.next;
        head.next = swapPairs(newhd.next);
        newhd.next = head;
        return newhd;
}
		\end{lstlisting}
	\item{迭代} : \fbox{时间复杂度O(n) , 空间复杂度O(1) }\\
		\begin{lstlisting}
class Solution {
public:
    ListNode *swapPairs(ListNode *head) {
    	ListNode *newHead = new ListNode(0), *idx = newHead;
    	idx->next = head;
    
    	while(idx && idx->next && idx->next->next){
    		ListNode *nnnext  = idx->next->next->next;
    		idx->next->next->next = idx->next;
    		idx->next = idx->next->next;
    		idx->next->next->next = nnnext;
    
    		idx = idx->next->next;
    	}
    
    	return newHead->next;
    }
};
		\end{lstlisting}

\end{description}

